%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer Presentation
% LaTeX Template
% Version 1.0 (10/11/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% Modified by Jeremie Gillet in November 2015 to make an OIST Skill Pill template
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND THEMES
%----------------------------------------------------------------------------------------

\documentclass{beamer}

\mode<beamer>{\usetheme{purduegold}}

%\mode<presentation> {

%\usetheme{Madrid}

%\definecolor{OISTcolor}{rgb}{0.65,0.16,0.16}
%\usecolortheme[named=OISTcolor]{structure}

%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line

%\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
%}

%\usepackage{fontspec}
%\usepackage{xeCJK}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{textpos} % Use for positioning the Skill Pill logo
\usepackage{transparent} % For transparency with images
\usepackage{textcomp} % To print otherwise protected symbols e.g. <,>

\usepackage{ulem} % For strikethrough.

% For code displays
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{array}

% Allows side-by-side presentation notes
\usepackage{pgfpages}
%\setbeameroption{show notes on second screen}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{Introduction to Git and Version Control} % The short title appears at the bottom of every slide, the full title is only on the title page
\subtitle{Lecture 1: Git ready!}

%\author{\textbf{James Schloss}} % Your name
\author{\textbf{Zhou Jiming}} % Your name
\institute[NWPU] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
Northwestern Polytechnical University \\ % Your institution for the title page
%\textit{james.schloss@oist.jp} % Your email address
}
\date{\today} % Date of the presentation

\begin{document}

%\setbeamertemplate{background}{\transparent{0.65}\includegraphics[width=\paperwidth]{SPbackground.png}} % Adding the background logo

\begin{frame}[plain]
\vspace*{1.4cm}
\titlepage % Print the title page as the first slide
\hfill \textbf{Slides forked from GIT}
\end{frame}

\setbeamertemplate{background}{} % No background logo after title frame

\addtobeamertemplate{frametitle}{}{% Adding the logo on the title screen after title frame
\begin{textblock*}{100mm}(.8\textwidth,-1.25cm)
\includegraphics[height=2cm]{SPwhite.png}
\end{textblock*}}


\begin{frame}[allowframebreaks]
\frametitle{Overview} % Table of contents slide, comment this block out to remove it

\tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this 
\end{frame}
\note{
	\begin{itemize}
	\item Why Git? I'll tell you what my motivations are, but what are your motivations for being here? 
	\end{itemize}
}

%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

%------------------------------------------------

\section{Why Git?}

\begin{frame}
\frametitle{Why Git?}
\begin{itemize}
\item Version control
\item Easily compare and merge changes between any version
\item Organize your work items
\end{itemize}
\begin{center}\includegraphics[width=0.9\textwidth]{beforeafter.jpg}\end{center}
\end{frame}
\note{
	Imagine I asked you to remove the red sharpie marker from the left hand side?
	\begin{itemize}
	\item Difficulty finding it
	\item Could dive right in, but might get poked by lot of sharp things on the way in
	\item Or you could dump everything out and start all over
	\end{itemize} 
}

\begin{frame}
\frametitle{Why Git?}
\begin{center}\includegraphics[width=0.5\textwidth]{stackedChairs.jpeg}\end{center}
\end{frame}
\note{
	Imagine I asked you to remove this chair. What difficulties would you face?
	\begin{itemize}
	\item How to access it safely
	\item Can't remove it without fearing everything will fall
	\end{itemize} 
}

\subsection{Traditional vs. Git Versioning}

\begin{frame}[fragile]
\frametitle{Traditional vs. Git Versioning}
\begin{itemize}
\item What changed when
\item Not limited to file name length to inform user of changes
\end{itemize}
\begin{center}\includegraphics[width=0.9\textwidth]{versioning.png}\end{center}
\end{frame}

\section{What is Git}

\subsection{Three Main Parts (Working Directory, Stage, Repository)}

\begin{frame}[fragile]
\frametitle{What is git?}
\begin{itemize}
\item A \textbf{Working Directory}: Just a folder where your files are
\item A \textbf{Staging Area}: A place to organize what exactly you want to version and what you don't
\item A \textbf{Repository}: Where the magic happens. 
\end{itemize}
\includegraphics[width=\textwidth]{git3MainItems.png}
\end{frame}
\note{
This chart might not make much sense now, but I hope it will before the end of these slides

Whether you realize it or not, you are already familiar with the "Working Directory". I'll save the staging area for a bit later, but first lets talk about what a repo is.}

\begin{frame}[fragile]
\frametitle{Repositories}
\begin{itemize}
\item A \textbf{repository} is a container for both your project data and all the items that allow interactions with git commands.
\begin{itemize}
\item There are many sites to host your repository on (github, bitbucket), including your own local machine.
\item All of the essential parts of your repository can be found in the \textbf{.git} directory
\item GitHub (a website hosting Git repositories) $\neq$ Git (a set of tools for creating and managing those repositories).
\end{itemize}
\end{itemize}
\includegraphics[width=\textwidth]{Storage.jpg}
\end{frame}

\section{How to Use Git}

\subsection{The Terminal}

\begin{frame}[fragile]
\frametitle{Terminal Talk}
\begin{columns}
\column{0.7\textwidth}
\begin{itemize}
\item There are multiple GUIs available for Git, such as one from GitHub called the \textbf{GitHub Desktop}. We will not be using this for \sout{religious} perfectly scientific reasons.
\item These reasons primarily revolve around flexibility and improved understanding of the Git tools.
\item Everything we do will be usable on Deigo.
\item The \textbf{Pro Git} book is available online at \href{https://git-scm.com/book/}{\textbf{\color{blue}{git-scm.com/book}}}
\item There is a cheatsheet for Git available here: \href{https://www.git-tower.com/learn/cheat-sheets/git}{\textbf{\color{blue}{https://www.git-tower.com/learn/cheat-sheets/git}}}
\end{itemize}
\column{0.3\textwidth}
\includegraphics[width=\textwidth]{terminal.png}
\end{columns}
\end{frame}
\note{
	\begin{itemize}
	\item I personally struggled with the terminal interface at first because most of the man pages use so much vocab I don't know to explain terms I don't know. Hopefully by the end of this mini-course you'll have the basic vocab down so you 	can help yourselves more efficiently going forward.
	\end{itemize}
}

\subsection{Create a repo}

\begin{frame}[fragile]
\frametitle{Create a Repo(sitory)}
\begin{columns}
\column{0.7\textwidth}
Let's \textbf{git} started.
\begin{itemize}
\item To initialize a git repository, simply type \textbf{git init} in a directory (preferably empty for now)
\item This creates a folder \textbf{.git/}, where all your repository information is held.
\end{itemize}
\column{0.3\textwidth}
\includegraphics[width=\textwidth]{git.jpg}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Create an Empty Repo}
    \begin{block}{EXERCISE}
        \begin{enumerate}
        \item Open a terminal
        \item Create a new directory called \textbf{myFirstRepo} and enter it.
	 \item This is your Working Directory. Thats it!
	 \item Run \textbf{git init} in your Working Directory.
        \item Take a peak in the newly created .git directory but don't touch anything quite yet.
        \end{enumerate}
    \end{block}

\end{frame}

\subsection{Commits}

\begin{frame}[fragile]
\frametitle{Commits}
\begin{itemize}
\item Conceptually similar to "versions"
\item The more effort you put into crafting these using the \textbf{staging area} the more helpful they are in the future.
\end{itemize}
\includegraphics[width=0.9\textwidth]{git_commit.png}
\end{frame}
\note{ Before we talk about the Stage we need to understand what commits are.
Show lego photos now}

\subsection{The Stage (Staging Area, or Index)}

\begin{frame}
\frametitle{Staging Changes}
\begin{center}
\includegraphics[width=0.75\textwidth]{lifecycle.png}
\end{center}
\begin{itemize}
\item A new file is initially \textbf{untracked}
\item When you use \textbf{git add}, it moves to the staging area and becomes \textbf{staged}
\item After being committed (using \textbf{git commit}), a file is up-to-date and considered \textbf{unmodified}
\item Changing a file makes it modified, but doesn't add it to the staging area
\end{itemize}
\end{frame}
\note{Go through car repo example, e.g. adding wheels and doors, but committing only one or the other.}

\begin{frame}[fragile]
\frametitle{Currating the Stage before Committing}
\begin{columns}
\column{0.7\textwidth}
\begin{itemize}
\item Check what is on the stage with \textbf{git status}. Anything in \textcolor{dkgreen}{green} is staged.
\item If you wish to unstage all changes, simply type \textbf{git reset}. This will remove everything from the stage, but keep your working directory untouched. 
\item \textbf{git reset} will work for individual files as well
        \begin{lstlisting}
git reset <file>
        \end{lstlisting}
\end{itemize}
\column{0.3\textwidth}
\includegraphics[width=\textwidth]{the-hook.jpg}
\end{columns}
\end{frame}
\note{As you saw a few slides ago. Adding messy or unnecessary commits doesn't help anyone. Lets discuss how to make meaningful helpful commits using the stage. There are various ways to fix bad commits, but it takes a whole lot less work to do it right the first time.}

\begin{frame}[fragile]
\frametitle{Try out the Stage}
	\begin{block}{EXERCISE}
		\begin{enumerate}
		\item Create a new emtpy file \textbf{myfile.txt}
		\item Check the status of everything with \textbf{git status}
		\item Add \textbf{myfile.txt} to the stage vis \textbf{git add myfile.txt}
		\item Check the status of everything again with \textbf{git status}. What changed?
		\item Unstage the changes with \textbf{git reset myfile.txt}
		\item Check the status of everything again with \textbf{git status}. What changed?
		\end{enumerate}
	\end{block}

\end{frame}


\begin{frame}[fragile]
\frametitle{Committing from the Stage}
\begin{itemize}
\item Git keeps track of \textbf{commits}. Check these commits with \textbf{git log}. There's plenty of options to show only what you want or everything under the sun. 
\item \textbf{git status} checks any changes since the last commit.
\item \textbf{git commit} commits everything in the \textit{staging area} - git status shows these files in {\color{dkgreen}green} by default.
\end{itemize}
\end{frame}

\subsection{Making Commits}

\begin{frame}[fragile,shrink]
\frametitle{Making Commits}
    \begin{block}{EXERCISE}
        \begin{enumerate}
        \item Repoen your \textbf{myFirstRepo} from before
	 \item Add the \textbf{myFile.txt} back to the stage with \textbf{git add myFile.txt}
	 \item Check the status of the stage with \textbf{git status}
        \item Once satisfied with what is in the stage and you're ready to commit, go ahead and do so with \textbf{git commit} to add your new file to the git repository. Be sure to add a meaningful commit message!
        \item Check the \textbf{git log}.
	 \item Check the \textbf{git status}
 	 \item Add a line of text to \textbf{myFile.txt} and save it.
	 \item Check the status of the stage with \textbf{git status}
	 \item Check the differences in the file with \textbf{git diff}
	 \item Once satisfied with your changes, add it back to the stage and commit. 
        \end{enumerate}
    \end{block}
\end{frame}

\subsection{Checking Out Past Commits}

\begin{frame}[fragile]
\frametitle{Checking out your past commits}
\begin{itemize}
\item \textbf{git checkout} allows you to view the repository at any commit (found with \textbf{git log}).
\item You may also checkout specific files like so: 
        \begin{lstlisting}
git checkout a1e8fb5 hello.py
        \end{lstlisting}
\item Note that the most recent commit is \textbf{HEAD} and the one just before that is \textbf{HEAD$\mathbf{\sim}$1}
\begin{center}\includegraphics[width=0.7\textwidth]{head.png}\end{center}
\end{itemize}
\end{frame}

\begin{frame}[fragile,shrink]
\frametitle{Checkout Your History}
    \begin{block}{EXERCISE}
        \begin{enumerate}
	 \item Add a second line of text to \textbf{myFile.txt} and save it.
	 \item Add these changes to the stage with \textbf{git add myFile.txt} and check the status with \textbf{git status}
        \item Once satisfied with what is in the stage and you're ready to commit, use \textbf{git commit} to add your new file to the git repository.
        \item Check the \textbf{git log}. You should have three commits by now.
	 \item Go checkout each of the commits with \textbf{git checkout \textlangle{}HASH\textrangle{}}, \textbf{git checkout HEAD\textasciitilde1}, or \textbf{git checkout HEAD\textasciitilde2}
	 \item See whats different with \textbf{ls -al} or \textbf{git status} or just open \textbf{myfile.txt} in your favorite text editor
	 \item When you are satisfied that your commit history is as expected you can return to the most recent commit with \textbf{git checkout master} (Note this could be \textbf{git checkout main} depending on your version of git.)
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Git Generally Only Adds}

\begin{itemize}
\item After you commit something it is fairly difficult to remove it.
\item This is a double edged sword. Low risk of losing anything permanently. High risk of creating a HUGE repo. 
\item Keep your repository clean! Do your best to commit as few images and data files as possible!
\item You can do this by ignoring certain file extensions in a \textbf{.gitignore} file.
\item Great templates for projects of many types found at \textbf{\href{https://github.com/github/}{https://github.com/github/gitignore}}
\end{itemize}
\begin{columns}
\column{0.5\textwidth}
\begin{lstlisting}
# Example gitignore configuration
*.log
*.tar
*.gz
*.exe
*.dat
*.lvlps
\end{lstlisting}
\column{0.5\textwidth}
\includegraphics[width=\textwidth]{IIB.jpg}
\end{columns}
\end{frame}
\note{My robot repo is now 500GB due to huge Solidworks CAD files.}

\begin{frame}[fragile]
\frametitle{Quick Exercise}
    \begin{block}{EXERCISE}
        \begin{enumerate}
        \item Touch multiple files with various extensions, one of which should be \textbf{.dat}.
        \item Ignore the \textbf{.dat} file, but commit all the others.
        \item Be sure to write a clear message describing what you did.
        \item Check the \textbf{git log}
        \end{enumerate}
    \end{block}

\end{frame}

\section{Working Online}

\begin{frame}
\frametitle{\textbf{git} with it!}
\begin{columns}
\column{0.7\textwidth}
Now we move to the fun* stuff: working with \textbf{online repositories}.
\begin{itemize}
\item For this, we will be using \textbf{github}.
\item We'll begin by creating a GitHub repository using the \href{www.github.com}{website}.
\begin{itemize}
\item If we're working on a project that's already hosted on a remote Git server, we can skip this step.
\end{itemize}
\item Next, we use \textbf{git clone} to download a copy.
\item From here, you can do the following:
\begin{itemize}
\item \textbf{git push} to push any changes you may have to the online repository.
\item \textbf{git pull} to take any changes from the repository.
\end{itemize}
\end{itemize}
\column{0.28\textwidth}
\includegraphics[width=\textwidth]{clone.jpg}
\end{columns}

*Here, the word \textit{fun} is subject to interpretation.
\end{frame}

\begin{frame}[fragile,shrink]
\frametitle{Quick Exercise}
    \begin{block}{EXERCISE}
        \begin{enumerate}
        \item Fork the \textbf{\href{https://github.com/oist/skillpill-git}{https://github.com/oist/skillpill-git}} repository using a browser.
        \item Clone the forked repository* to your local disk:
        \begin{lstlisting}
git clone git@github.com:<git_user_name>/skillpill-git.git
        \end{lstlisting}
        or
        \begin{lstlisting}
git clone https://github.com/<git_user_name>/skillpill-git.git
        \end{lstlisting}
        \item Make some simple commits and test the process of \textbf{push}ing and \textbf{pull}ing stuff from that repo.
        \end{enumerate}
    \end{block}

*The examples here show cloning the SkillPill Git repository - replace the links as appropriate!
\end{frame}

\section{Wrap Up}

\begin{frame}
\frametitle{What it will feel like...}
\begin{columns}
\column{0.6\textwidth}
\begin{itemize}
\item git is not intuitive to start with, but it's %the best way to work collaboratively with other people.
a powerful tool for storing and restoring history, and working collaboratively with other people.
\item The more you use it, the more you will like it. Think Stockholm syndrome.
\item Operations that you use frequently will become easy.
\item Operations you use infrequently, you can Google!
\end{itemize}
\column{0.4\textwidth}
\includegraphics[width=\textwidth]{gitxkcd.png}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Final Comments}
\begin{columns}
\column{0.7\textwidth}
\begin{itemize}
\item git is weird. It's not intuitive, but it's the best way to collaborate with people on open projects.
\item It's also great even if you don't collaborate!
\item Whenever you are using git, think about other people and how they will perceive your comments. \textbf{Would you be able to understand your own cryptic commit messages?}
\item You will make mistakes. Don't worry about it. Your entire history is backed up already. Learn from your mistakes and don't make them again!
\item Read error messages carefully - they can be useful/informative/instructive.
\end{itemize}
\column{0.3\textwidth}
\includegraphics[width=\textwidth]{light-bulb.jpg}
\end{columns}
\end{frame}

\section{Extra Credit}

\begin{frame}
\frametitle{(If Time Allows) Modifying Previous Commits}
\begin{itemize}
\item If you commit something that turns out to be a mistake, don't worry! There are plenty of tools to rework commits.
\item Some are more powerful (and potentially distructive than others)
\item Non-destructive: (Leaves history intact)
	\begin{itemize}
	\item \textbf{revert}
	\end{itemize}
\item Potentially destructive: (Changes history)
	\begin{itemize}
	\item \textbf{rebase}
	\end{itemize}
\item Danger Zone: (Can erase history)
	\begin{itemize}
	\item \textbf{reflog}
	\end{itemize}
\end{itemize}
\end{frame}

\subsection{Revert}

\begin{frame}[fragile]
\frametitle{Using Revert}
\begin{itemize}
\item Revert makes a new commit showing that you reverted a previous commit.
\item Pro: This is very useful for public repos (next session) where you want to show exactly what you've undone to others.
\item Con: This can make your commit history quite messy if used too often. 
\end{itemize}
    \begin{block}{EXERCISE}
        \begin{enumerate}
        \item Make a few commits to your \textbf{myFirstRepo} or just use the existing history of your skill-pill fork
	 \item Find a commit you want to revert using \textbf{git log} and \textbf{git show} or \textbf{git diff}
	 \item Revert that commit with \textbf{git revert \textlangle{}HASH\textrangle{}} or \textbf{git revert HEAD\textasciitilde\textlangle{}\#\textrangle{}}
        \end{enumerate}
    \end{block}
\end{frame}

\subsection{Rebase}

\begin{frame}[fragile]
\frametitle{Using Rebase}
\begin{itemize}
\item Rebase rewrites the commit history by starting from specified base commit and choosing what to do with each commit all the way to the current HEAD.
\item Pro: Great for removing WIP commits or otherwise meaningless commits. Use it to clean up your local history before pushing to a public repo.
\item Con: This has the possiblity to create a lot of conflicts if used in a shared repo (as one person's history will differ from another). Generally rebase should not be used on any commits you have pushed to a public repo. 
\end{itemize}
    \begin{block}{EXERCISE}
        \begin{enumerate}
        \item Make a few commits to your \textbf{myFirstRepo} or just use the existing history of your skill-pill fork
	 \item Making a meaningless WIP commit
	 \item Use \textbf{git rebase -i \textlangle{}HASH\textrangle{}} and follow the instructions
        \end{enumerate}
    \end{block}
\end{frame}

\section{Recap}
\begin{frame}{Recap}
  Last week we covered (don't forget to prefix with \textbf{git}):
  \begin{itemize}
    \item \textbf{clone} : Cloning a repository into a new directory
    \item \textbf{add} : Add file contents to the \textit{index}. This makes git track the file.
    \item \textbf{commit} : Record changes. Store the staged files as a new part of the history!
    \item \textbf{push} : Update remote \textit{refs} and objects.
	\end{itemize}
	There\rq{}s also a \textbf{pull} command.
	\begin{itemize}
		\item \textbf{pull} : Update from a \textit{remote}. Technicially a combination of \textbf{fetch} and \textbf{merge} by default.
	\end{itemize}
\end{frame}

\begin{frame}{Some definitions/descriptions}
	\renewcommand{\arraystretch}{2.5}
	\begin{tabular}{m{0.2\textwidth}m{0.6\textwidth}}
	  \textit{remote} & Another git repository. \newline We used GitHub to provide this. \\
	  \hline
  		\textit{index} & A single, large, binary file listing all files in the current branch with some extra information. \newline Reflects the \lq\lq{}proposed next commit\rq\rq{} \\
  		\hline
	  \textit{refs} & Short for references. \newline Can point to almost anything in git.
  \end{tabular}
  	\renewcommand{\arraystretch}{1}
\end{frame}

\begin{frame}{Tips so far...}
  \begin{itemize}
    \item You can use \texttt{git help <command>} or \texttt{git <command> --help} to get information about a command, like \texttt{clone}.
    \item \texttt{git add \textbf{-p}} uses \textit{patch mode} to interactively add parts of a file. \textbf{-i} is interactive without patch mode.
    \item \texttt{git rm} can be used to remove files from the index (and optionally working directory), whilst \texttt{git mv} can help you move files within the repository.
    \item \texttt{git commit --amend} opens an editor to alter the previous commit's message. Don't do this if you already \textbf{push}ed the commit!
  \end{itemize}
\end{frame}

\begin{frame}{Reset and Checkout}
  We also considered \textbf{reset} and \textbf{revert}.
  \begin{itemize}
    \item Reset is a fairly complicated tool, which modifies the three \lq{}trees\rq{} we have briefly mentioned/considered - \texttt{HEAD} (your last commit), \texttt{index} (the staging area) and the \texttt{working directory}.
    \item If you\rq{}re interested to know more about this tool, there is a long and informative guide at \url{https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified}.
    \item This content is really beyond the scope of our Skill Pill. :(
  \end{itemize}
\end{frame}


\section{Working with Remotes}
\subsection{Remotes}
\begin{frame}{Remotes}
Last week we introduced \textbf{GitHub}. GitHub is a service that offers you a solution to remotely store your repositories.
\begin{itemize}
    \item Git is \emph{Distributed} Version Control System (DVCS). Every copy of your repository, may it be remote or local, is independent of each other. There is no central master repository. 
    \item In order to synchronize these distributed copies we introduce the concept of a remote.
  \begin{block}{}
    git \textbf{remote}
  \end{block}
  \item There can be as many remotes as you want each with different names. When you clone a repository there will be one default remote called \textbf{origin}.
\end{itemize}
\end{frame}

%\begin{frame}
%  \begin{block}{Exercise 1a}
%    \begin{enumerate}
%      \item Tell Jeremie your GitHub user name so you can be added to the allowed committers for the repository...
%      \item Clone this repository from GitHub: \url{https://github.com/oist/skillpill-git-group1}
%      \item Add your favourite color to the colors file.
%      \item Commit your change with an appropriate message, but don\rq{}t \textbf{push}!
%    \end{enumerate}
%  \end{block}
%\end{frame}
%
%\begin{frame}
%  \begin{block}{1b: Alternative Exercise if I can\rq{}t get access to the repository...}
%    \begin{enumerate}
%      \item Create an empty directory for your repositories (note plural)
%      \item In this directory, \texttt{A}, create a new directory, called \lq{}myremote\rq{} (or change as needed below).
%      \item Change into this new directory, and run \texttt{git init --bare}. This creates a \lq{}bare\rq{} repository, in which nothing is checked out.
%      \item Move back into directory A. Create a new directory, and then run \texttt{git init} (not bare), add a file, and commit it.
%      \item Run the command \texttt{git remote add origin ../myremote/}, which adds a remote repository called \lq{}origin\rq{}, pointing to the directory \lq{}myremote\rq{}.
%    \end{enumerate}
%  \end{block}
%\end{frame}
%\begin{frame}
%  \begin{block}{1b: Alternative Exercise Continued...}
%    \begin{enumerate}
%      \setcounter{enumi}{5} % Continue counting from 6 (5 points in previous slide)
%      \item Push your commit with the command \texttt{git push -u origin master}, which sets your branch to track the new branch \lq{}master\rq{} on \lq{}origin\rq{}.
%      \item Go back to A. Clone your \lq{}myremote\rq{} repository with the command \texttt{git clone myremote secondcopy} (a new directory named \lq{}secondcopy\rq{} will be created).
%      \item Make changes to your file in both your first repository, and \lq{}secondcopy\rq{} (not \lq{}myremote\rq{}). Commit both. Push from only the first repository (not \lq{}secondcopy\rq{}).
%    \end{enumerate}
%  \end{block}
%\end{frame}

\subsection{Branches}
\begin{frame}{Branches}
  Since there git is decentralized there is no one state of the repository that is correct. To manage this complexity git has the notion of a branch. 
  \begin{block}{}
    \begin{itemize}
      \item git \textbf{branch}  Manages branches. 
      \item git \textbf{checkout} Switch between branches.
    \end{itemize}
  \end{block}

  \begin{itemize}
    \item Most repositories have a default branch called \textbf{master} (this is changing to "main" in some cases). Branches are just names for points in the history.
    \item Once we start working with branches we have to ask ourselves how are we going to join them back up? We can do this by performing a merge.
    \item You can also associate a local branch with a remote branch by setting it as upstream. git push \textbf{-u}.
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{block}{Exercise}
    \begin{enumerate}
      \item Create a new branch, based of master
      \item Add a few commits to your branch
      \item Change back onto master
      \item Check the contents of the file(s) you changed on your other branch whilst you\rq{}re on the master branch
    \end{enumerate}
  \end{block}
\end{frame}

\subsection{Merging}
\begin{frame}{Merging - An Introduction}
  \begin{itemize}
    \item We perform \textit{merges} to \lq\lq{}join two or more development histories together\rq\rq{}.
    \item It is most commonly performed invisibly by \texttt{git pull} and performs by default a \lq\lq{}fast-forward\rq\rq{} merge.
    \item We usually see this first when we try to pull some changes and we cannot perform a fast-forward merge.
    \item In that case, we have to resolve the \textit{merge conflict}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Merging}
Merging is the act of joining two branches together or to join two different branches. You will always merge \emph{from} a branch/remote into a branch.
  \begin{block}{}
    \begin{itemize}
      \item git \textbf{fetch}  Gets remote changes
      \item git \textbf{merge}  Merge changes (ff by default)
      \item git \textbf{add}    Resolve merge-conflict
    \end{itemize}

    Options for merge:
    \begin{description}
      \item[--no-commit] Performs the merge, but doesn't commit yet. Gives you a chance to edit the merge commit.
      \item[--ff-only]   Aborts when we can't perform a fast-forward merge.
      \item[--abort]     Aborts current conflict-resolution and reset to previous state.
    \end{description}
  \end{block}

  You can visualize your history in many different ways, but a nice way from the command line is.\\
  \begin{block}
  git log \textbf{--graph --decorate --oneline --all}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Exercise}
    \begin{enumerate}
    	\item \textbf{Clone} a fork of the repository at \url{https://github.com/oist/skillpill-git} (you may have this available from last week)
		\item \textbf{Checkout} the `merge-main' branch
		\item \textbf{Merge} the `merge-AddNameToGreeting' branch. Optionally use ``--no-ff'' to force a merge commit. This will succeed without conflict.
		\item Attempt to merge the `merge-TimeOfDayGreeting' branch. This will cause a merge conflict!
	\end{enumerate}
  \end{block}
\end{frame}

\begin{frame}[fragile]
	\begin{lstlisting}[language=Python, title={Merge conflict contents}, basicstyle=\tiny]
def main(username, timeValue):
<<<<<<< HEAD
    print("Hello " + username)

def callFctn(args):
    if len(args) > 1:
        username = args[1]
    else:
        username = "World"

    timeValue = ""
=======
    greeting = getGreeting(timeValue)
    print(greeting + " " + username)

def callFctn(args):
    username = "World"
    
    if len(args) > 1:
        try:
            timeValue = time.strptime(args[1], "%H:%M")
        except:
            timeValue = ""
    else:
        timeValue = ""

>>>>>>> merge-TimeOfDayGreeting
	\end{lstlisting}
\end{frame}

\begin{frame}
  \begin{block}{Exercise continued}
    \begin{enumerate}
    	\setcounter{enumi}{4}
	    \item Use a text editor to resolve the conflict
		\item Commit the resolved file (don't forget to \textbf{add})
		\item Push your branch to your forked repository
	\end{enumerate}
  \end{block}
  This brings us on to ``Pull Requests''...
\end{frame}


%\begin{frame}[fragile]{Interlude: .gitconfig}
%  The file \emph{.gitconfig} can be used to set default options per user or per project. The user files is in \emph{\textasciitilde/.gitconfig}. Each option can also be set with git \textbf{config}.
%  \begin{lstlisting}
%  [user]
%    email = v.churavy@gmail.com
%    name  = Valentin Churavy
%  [github]
%    user = vchuravy
%  [push]
%    default = simple
%  [rerere]
%    enabled = true
%  \end{lstlisting}
%\end{frame}


\section{Pull Requests on GitHub}
\begin{frame}{Pull Requests}
  \begin{itemize}
    \item Pull Requests are a GitHub-specific feature (also implemented on other platforms, but not a git feature) used to allow contributing code to a repository.
    \item They are typically used when you don\rq{}t have write access to a repository
    \item They can also be used to allow review of your code, perhaps by a coworker, even if you could directly push your changes
    \item Without using extensions, you must use the website to use them
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{block}{Demo + Exercise}
    \begin{itemize}
      \item Demonstration...
      \item Practice:
      \begin{enumerate}
        \item In the last exercise we pushed commits to forks of the OIST repository
        \item Open a pull request on GitHub against the original repository
      \end{enumerate}
    \end{itemize}
  \end{block}
\end{frame}

\section{More Advanced Topics}
\subsection{Rebasing and Rewriting history}
\begin{frame}[fragile]{Rewriting History}
  Rebases are a way to create fast-forward merges, by altering \emph{history}. Each branch has a root commit from which it diverged from the original commit. By rebasing we change this root. This has a couple of side effects. 
  \begin{itemize}
    \item Linear commit history.
    \item No merge commits within a branch.
    \item commit-ids change.
  \end{itemize}

  \begin{block}{}
    \begin{itemize}
      \item git \textbf{pull --ff-only} Don't merge if there are conflict with the remote
      \item git \textbf{rebase} Perform a rebase
      \item git \textbf{rebase -i} Perform a interactive rebase
      \item git \textbf{push -f} Force push your changes
      \item git \textbf{pull --rebase} Perform a pull with a rebase
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Exercise}
    \begin{enumerate}
      \item create a branch, with some commits
      \item go back to master and do some additional work
      \item rebase your branch onto master
      \item merge your branch onto master
    \end{enumerate}
  \end{block}
\end{frame}

\begin{frame}[allowframebreaks,fragile]{Secrets!}
 \begin{block}{Stash}
    When you are moving between branches you sometines want to keep your non-commited changes associated with the branch you where doing them one.
    \begin{itemize}
      \item git \textbf{stash}
      \item git \textbf{stash pop}
    \end{itemize}
  \end{block}

  \begin{itemize}
    \item git commit \textbf{--amend} Amend the last commit.
    \item git add \textbf{-i} Interactive add
    \item git add \textbf{-p} Interactive add in patch mode.
    \item git \textbf{rm} Removes file.
    \item git \textbf{mv} Move file within repository
  \end{itemize}
  
  \framebreak
    
  \begin{block}{Autosquash}
    \begin{itemize}
      \item git config rebase.autosquash true
      \item git commit \textbf{--squash=}\emph{some-hash}
      \item git commit \textbf{--fixup=}\emph{some-hash}
     \end{itemize}
     Autosquash will reorder the commits appropriatly before you perform a git \textbf{rebase -i}.
  \end{block}
  \begin{block}{Blame}
    There is no such thing as \textit{good} code. If you are using git with people, chances are that something will break at some time and you need someone to blame. That's what git blame is for:
    \begin{lstlisting}
        git blame -L 1,3 file
    \end{lstlisting}
  \end{block}
\end{frame}

\end{document} 

